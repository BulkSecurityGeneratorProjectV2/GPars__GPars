Dataflow Operators provide a full Dataflow implementation with all the usual ceremony.

h3. Concepts

{code}
operator(inputs: [a, b, c], outputs: [d]) {x, y, z ->
    ...
    bindOutput 0, x + y + z
}
{code}

{code}
/**
 * CACHE
 *
 * Caches sites' contents. Accepts requests for url content, outputs the content. Outputs requests for download
 * if the site is not in cache yet.
 */
operator(inputs: [urlRequests], outputs: [downloadRequests, sites]) {request ->

    if (!request.content) {
        println "[Cache] Retrieving ${request.site}"
        def content = cache[request.site]
        if (content) {
            println "[Cache] Found in cache"
            bindOutput 1, [site: request.site, word:request.word, content: content]
        } else {
            def downloads = pendingDownloads[request.site]
            if (downloads != null) {
                println "[Cache] Awaiting download"
                downloads << request
            } else {
                pendingDownloads[request.site] = []
                println "[Cache] Asking for download"
                bindOutput 0, request
            }
        }
    } else {
        println "[Cache] Caching ${request.site}"
        cache[request.site] = request.content
        bindOutput 1, request
        def downloads = pendingDownloads[request.site]
        if (downloads != null) {
            for (downloadRequest in downloads) {
                println "[Cache] Waking up"
                bindOutput 1, [site: downloadRequest.site, word:downloadRequest.word, content: request.content]
            }
            pendingDownloads.remove(request.site)
        }
    }
}
{code}

The standard error handling will print out an error message to standard error output and stop the operator in case an uncaught
exception is thrown from withing the operator's body. To alter the behavior, you can redefine the _reportError()_ method
on the operator:

{code}
    op.metaClass.reportError = {Throwable e ->
        //handle the exception
        stop()  //You can also stop the operator
    }
{code}

h4. Parallelize operators

By default an operator's body is processed by a single thread at a time. While this is a safe setting allowing the operator's
body to be written in a non-thread-safe manner, once an operator becomes "hot" and data start to accumulate in the operator's
input queues, you might consider allowing multiple threads to run the operator's body concurrently. Bear in mind that in such a case
you need to avoid or protect shared resources from multi-threaded access.
To enable multiple threads to run the operator's body concurrently, pass an extra _maxForks_ parameter when creating an operator:

{code}
    def op = operator(inputs: [a, b, c], outputs: [d, e], maxForks: 2) {x, y, z ->
        bindOutput 0, x + y + z
        bindOutput 1, x * y * z
    }
{code}

The value of the _maxForks_ parameter indicates the maximum of threads running the operator concurrently. Only positive
numbers are allowed with value 1 being the default.
