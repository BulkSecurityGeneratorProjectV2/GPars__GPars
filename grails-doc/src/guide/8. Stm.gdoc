Software Transactional Memory (STM) gives developers transactional semantics for accessing in-memory data. When multiple threads
share data in memory, by marking blocks of code as transactional (atomic) the developer delegates to the Stm engine the responsibility
for making sure that all manipulated data remain consistent.
GPars leverages the Multiverse Stm engine. Check out more at the "Multiverse site":http://multiverse.codehaus.org/overview.html

h3. Running a piece of code atomically

GPars allows developers to specify transaction boundaries by using the _atomic_ blocks.

{code}
import groovyx.gpars.stm.GParsStm
import org.multiverse.api.references.IntRef
import static org.multiverse.api.StmUtils.newIntRef

public class Account {
    private final IntRef amount = newIntRef(0);

    public void transfer(final int a) {
        GParsStm.atomic {
            amount.increment(a);
        }
    }

    public int getCurrentAmount() {
        GParsStm.atomicWithInt {
            amount.get();
        }
    }
}
{code}

There are several types of _atomic_ blocks, each for different type of return value:
* _atomic_ - returning _Object_
* _atomicWithInt_ - returning _int_
* _atomicWithLong_ - returning _long_
* _atomicWithBoolean_ - returning _boolean_
* _atomicWithDouble_ - returning _double_
* _atomicWithVoid_ - no return value

h3. Customizing the transactional properties

Frequently it may be desired to specify properties of the transactions. The _createAtomicBlock_ method will create a new _AtomicBlock_
configured with the supplied values:

{code}
import groovyx.gpars.stm.GParsStm
import org.multiverse.api.AtomicBlock
import org.multiverse.api.PropagationLevel

final AtomicBlock block = GParsStm.createAtomicBlock(maxRetries: 3000, familyName: 'Custom', PropagationLevel: PropagationLevel.Requires, interruptible: false)
assert GParsStm.atomicWithBoolean(block) {
    true
}
{code}

h3. Using the _Transaction_ object

The closures that run atomically are provided the current _Transaction_ as a parameter. The _Transaction_ objects can then be used
 to manually control the transaction.
This is illustrated in the example below, where we use the _retry()_ method to block the current transaction until the counter reaches the desired value:
 {code}

import groovyx.gpars.stm.GParsStm
import org.multiverse.api.AtomicBlock
import org.multiverse.api.PropagationLevel
import static org.multiverse.api.StmUtils.newIntRef

final AtomicBlock block = GParsStm.createAtomicBlock(maxRetries: 3000, familyName: 'Custom', PropagationLevel: PropagationLevel.Requires, interruptible: false)

def counter = newIntRef(0)
final int max = 100
Thread.start {
    while (counter.atomicGet() < max) {
        counter.atomicIncrementAndGet(1)
        sleep 10
    }
}
assert max + 1 == GParsStm.atomicWithInt(block) {tx ->
    if (counter.get() == max) return counter.get() + 1
    tx.retry()
}
{code}