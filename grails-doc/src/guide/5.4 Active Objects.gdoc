Active objects provide a OO facade on top of actors, allowing you to avoid dealing directly with the actor machinery,
matching messages or sending replies.

h2. Actors with a friendly facade
{code}
import groovyx.gpars.activeobject.ActiveObject
import groovyx.gpars.activeobject.ActiveMethod

@ActiveObject
class Decryptor {
    @ActiveMethod(blocking = true)
    String decrypt(String encryptedText) {
        return encryptedText.reverse()
    }

    @ActiveMethod(blocking = true)
    Integer decrypt(Integer encryptedNumber) {
        return -1*encryptedNumber + 142
    }
}

final Decryptor decryptor = new Decryptor()
print decryptor.decrypt(' noitcA ni yvoorG')
print decryptor.decrypt(140)
println decryptor.decrypt('noittide dn')
{code}

You mark active objects with the _@ActiveObject_ annotation. This will ensure a hidden actor instance is created for each instance of your class.
Now you can mark methods with the _@ActiveMethod_ annotation indicating that you want the method to be invoked asynchronously
by the target object's internal actor.
An optional boolean _blocking_ parameter to the _@ActiveMethod_ annotation specifies, whether the caller should block until a result is available
or whether instead the caller received only a _promise_ for a future result in a form of a _DataFlowVariable_ and so the caller is not blocked waiting.

{note}
By default, all active methods are set to be *non-blocking* . However, methods, which declare their return type explicitly, must be configured
as blocking, otherwise the compiler will report an error. Only _def_ , _void_ and _DataFlowVariable_ are allowed return types for non-blocking methods.
{note}

Under the covers, GPars will translate your method call to a message being sent to the actor. The actor will eventually handle that message by invoking the desired method
and sending back the reply.

h3. But waiting means we're not really asynchronous, are we?

No, we're not. All we've achieved so far is being thread-safe inside the Active object from concurrent access. Something the _synchronized_
keyword could give you cheaper and with less hassle.

The real fun begins once you allow your methods return promises for results, aka _DataFlowVariables_ .

{code}
import groovyx.gpars.activeobject.ActiveMethod
import groovyx.gpars.activeobject.ActiveObject
import groovyx.gpars.dataflow.DataFlowVariable

@ActiveObject
class Decryptor {
    @ActiveMethod
    def decrypt(String encryptedText) {
        new DataFlowVariable() << encryptedText.reverse()
    }

    @ActiveMethod
    def decrypt(Integer encryptedNumber) {
        new DataFlowVariable() << -1*encryptedNumber + 142
    }
}

final Decryptor decryptor = new Decryptor()
def firstPart = decryptor.decrypt(' noitcA ni yvoorG')
def secondPart = decryptor.decrypt(140)
def thirdPart = decryptor.decrypt('noittide dn')

print firstPart.get()
print secondPart.get()
println thirdPart.get()
{code}

Now calling the method will return as soon as the actor is sent a message. The caller is now allowed to do whatever he likes, while the actor is taking care of the calculation.
Calling the _get()_ method on the returned promise will block until a value is available. The state of the calculation can be polled using the _bound_ property on the promise.
The call to _get()_ will eventually return a value or throw an exception, depending on the outcome of the actual calculation.

{note}
The _get()_ method has also a variant with a timeout parameter, if you want to avoid the risk of waiting indefinitely.
{note}

h4. Annotation rules

There are a few rules to follow when annotating your objects:
# The _@ActiveMethod_ annotations are only accepted in classes annotated as _@ActiveObject_
# Only instance (non-static) methods can be annotated as _@ActiveMethod_
# You can override active methods with non-active ones and vice versa
# Subclasses of active objects can declare additional active methods, provided they are themselves annotated as _@ActiveObject_
# Combining concurrent use of active and non-active methods may result in race conditions. Ideally design your active objects as completely encapsulated classes with all public methods active

h3. Inheritance

The _@ActiveObject_ annotation can appear on any class in an inheritance hierarchy. The actor field will only be created in the first annotated class in the hierarchy, the subclasses will reuse the field.

{code}
import groovyx.gpars.activeobject.ActiveObject
import groovyx.gpars.activeobject.ActiveMethod
import groovyx.gpars.dataflow.DataFlowVariable

@ActiveObject
class A {
    @ActiveMethod
    def fooA(value) {
        ...
    }
}

class B extends A {
}

@ActiveObject
class C extends B {
    @ActiveMethod
    def fooC(value1, value2) {
        ...
    }
}
{code}

In our example the actor field will be generated into class _A_ . Class _C_ has to be annotated with _@ActiveObject_ since it holds
the _@ActiveMethod_ annotation on method _fooC()_ , while class _B_ does not need the annotation, since none of its methods is active.

h3. Groups

Just like actors can be grouped around thread pools, active objects can be configured to use threads from particular parallel groups.
{code}
@ActiveObject("group1")
class MyActiveObject {
    ...
}
{code}

The _value_ parameter to the _@ActiveObject_ annotation specifies a name of parallel group to bind the internal actor to.
Only threads from the specified group will be used to run internal actors of instances of the class.
The groups, however, need to be created and registered prior to creation of any of the active object instances belonging to that group.
If not specified explicitly, an active object will use the default actor group - _Actors.defaultActorPGroup_ .

{code}
final DefaultPGroup group = new DefaultPGroup(10)
ActiveObjectRegistry.instance.register("group1", group)
{code}

h3. Alternative names for the internal actor

You will probably only rarely run into name collisions with the default name for the active object's internal actor field.
May you need to change the default name _internalActiveObjectActor_ , use the _actorName_ parameter to the _@ActiveObject_ annotation.

{code}
@ActiveObject(actorName = "alternativeActorName")
class MyActiveObject {
    ...
}
{code}

{note}
Be careful when redefining the actor field's name for a subclass of an active object. This will result in two actors backing up
your active objects.
{note}
//todo inheritance with different actor field names allows for multiple actors per instance
//todo subclass changing group name
//todo overriding methods with different blocking semantics - test